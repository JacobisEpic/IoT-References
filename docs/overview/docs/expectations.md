# Course Overview, Expectations, Grading


This course is designed to cover a mashup of technologies required to
design and build wireless connected applications serving a variety of
different physical and virtual computing problems. The course is
***hands-on and lab-oriented*** and is structured to be task
driven. ***There will be no formal lectures in the course.*** Instead,
students will perform individual and team-based problems
dictated by outcomes which ***will require individual investigation,
discovery, and implementation*** using resources gleaned from the web.
The individual problems are intended to develop experience and skills
with the basic building blocks for the many technologies used whereas
the team-based assignments will synthesize the building blocks into
functional applications.  In the course structure these are called
***skills and quests***. Because the quests require underlying skills,
the quests are dependent on completion of the individual
skill-building problems ("skill clusters").

<center><img src="/docs/images/Gamify.png" width="90%" /></center>
<center> </center>

## Expectations
This course will require some effort. But it will be
unlike most of your other courses in that you will be working with
real device building blocks and creating real connected products. I
think it’s fun to build things and this course will give you that
opportunity.

- This course is not for everyone. Some people thrive on the discovery
  process; others dislike the absence of traditional lectures.  If it
  is not for you, please consider dropping quickly to open up a spot
  from the waiting list.
- The course will involve working with a bare-bones Microcontroller
  that will be programmed in C. If you are not prepared to code in C,
  then you should plan to get prepared before attending or drop the
  course.
- The course assumes a basic knowledge of circuits and
  electronics. Ohms Law, voltage dividers, current, voltage, power,
  etc.  This will be required for using sensors, driving motors, and
  not burning things up.  If you don't want to be hands-on, then this
  is not the right course for you.
- The EC 311 prerequisite is intended to establish that you are
  prepared to work with (binary) logic for bit twiddling.
- The EC 327 prerequisite is intended to establish that you are
  prepared to solve problems using software design and
  implementation. This means being able to conceptualize a problem
  solution and to translate this into code.
- We also use other programming languages, such as Javascript for
  building basic web functionality.  And Python. We expect you to
  pick up and learn these to complete some of the modules.

## Class Time

All of our class time will be active studio development time. You must
attend to work with your teammates. If you are unavailable for a good
reason, you must notify the instructor and your teammates of your
absence prior to the class that you are missing. You will need to
group problem-solve and this is best done during the course blocks.

The class flow will be approximately as follows:

1. About 10 min introducing new topics or overviewing the tasks for each class. 
These short presentations establish the work for the day.
2. Students will break into teams to complete tasks (skills and quests)
3. The instructor and TAs will rotate through meeting with teams for the duration of the session
depending on the session we may service groups based on demand requests
4. We will sometimes introduce design exercises or in-class challenges to mix things up

In summary -- you will be working on skills and quests with your team
and meeting with the instructor and the TA in each cycle.

## Kits

First of all, you are required to have your own computer and to
install and maintain your own development software. The software works
with the microcontroller kit and the other packages to be used.

Each student will receive and be responsible for a personal lab
kit. You will need to return this kit at the end of the course or
immediately if you drop the course (we have a limited number of kits).

In addition to the kit, each student will be expected to have
available (or purchase) the following items (these items are not in
the lab kit).

- Available USB-A ports on your laptop – if you have USB-C you will need converters or a USB-C to USB-A hub
- Windows, Linux, or Mac; or equivalent computer (IOS tablets will not be sufficient)

<!---
Note that the ESP32 part is required for the the first assignment.

We provide an ESP32, but it may be burnt due to misuse. This can
happen, don't feel bad, but you may need to purchase a new if it does

- [ESP32 microcontroller with USB charging cable (1
  unit)](https://www.adafruit.com/product/3591) (with or without
  soldered headers) $20

--->

## Rules for Individual Problems (Skills)

Please come to class prepared by reviewing (reading) the units
scheduled for the current class. A deep read is not required, but when
the instructor presents the concepts, you should already have a sense
of what will be covered. This is a small ask. Alternatively I can have
quizzes on class preparation, but I would rather not do that.

Individual  problem assignments  comprise the  experiences and  skills
required for competency  in the span of topics in the course. All
students are expected to complete, individually, on their own, the set
of  individual skill  problems assigned.  These skills  are aggregated
into clusters associated with each  quest. This is consistent with the
course being quest-driven. 

Individual problem assignments require reporting on results including
posting of developed code and supporting images via github.
Assessment and grading will be based on these reports and any other
evidence of individual contributions including interaction on Piazza and GitHub.

## Rules for Group Assignments (Quests)

There will be six quests of increasing complexity in the course. The
quests will combine skills obtained into more interesting combinations
of technology to build various smart and connected systems.  The
intent is for students to complete the skill assignments in a quest
cluster prior to performing the quest. This is the "scaffolding" of
course content. In any case, quests and skill clusters for a quest are
due at the same time.

Quests will be assessed based on a scheduled in-class demonstration by
each team plus completion of a written summary (as README.md) posted
to each team's github repo. The written summary must include links to
(a) a video presentation not to exceed 90 seconds that includes a
technical overview of the work, and (b) a video demonstration not to
exceed 90 seconds that includes the quest solution with each of the
required elements indicated in the quest rubric. If a team is unable
to demonstrate during the in-class assessment period, the video
presentation will entirely replace the in-person assessment and Q&A.
This is usually a disadvantage as important points may be missed in
the video and there is no option to remedy a missing element prior to
the submission deadline. Detailed reporting requirements and examples
are found in the utilities section of this site.

***Each student must appear in the submitted video. Failure to include each
   student will result in a deduction of 10% of the quest score.***

Quest teams will be established at the start of the course with a
brief period to enact changes. Teams will be comprised of 3 students.
Quests and individual assignment due dates are indicated in the quest
list.

## Collaboration

***You are expected to collaborate on quests within your quest
team.*** Collaboration will be realized through private github groups unique to
the team and quest.

You are expected to complete individual assignments on your own. We
want each and every person completing the individual assignments and
gaining the knowledge and experience from doing so. Copying another
student's work will be considered a violation of student conduct. 

## Piazza

We will use Piazza for communication to/from instructors as teams and
individuals. We encourage the use of posting for help or sharing
discoveries or approaches to problem solving. Efforts by students to
help others in debugging and problem solving are encouraged and will
be recognized as individual contributions. This should not conflict
with the collaboration policy. Participation in Piazza, especially to
resolve other students' issues, will support input to the grading
process. To this end, ***please make postings public unless you have a
specific need to make the communication private to the instructors.***

## Grading

Grading will be based on success in completing skill assignments and quests
as follows:

- 6 quests, 100 points each --> 600 points total
  - 75% objective assessment based on required elements
  - 25% qualitative assessment (design, reporting etc.)
- 6 skill clusters of 5-6 skills, 10 points/skill --> approx. 360 points total
  - Evidence of successful completion: 10 pts
  - Modest attempt: 5 pts
  - Weak or no attempt: 0 pts

Combining individual problem scores and quest scores will give
approximately 960 total points in the course.  This total may change
based on inclusion or exclusion of content and the realized pace of
the course.

## Re-dos

If you are unhappy with a score on an individual assignment we will
allow you to resubmit assignments up until the introduction of the
last quest (Quest 6). Re-dos must call out what was changed, and
require notifying us of the resubmission via Piazza. We may revoke this policy at
any time if it is abused.

## Final Exam

There will be no final exam in the class.

## Late Assignments

All reports related to Quests and associated skill clusters are ***due
at 11:59PM*** on the dates assigned. You will be allowed one exception for quest
submission. This exception will grant up to 5 days extension on
submitting the quest. You must notify the instructor and teammates via
Piazza if you intend to use your extension.

Late skill submissions will be discounted by 10%. No late skills will
be accepted after the introduction of Quest 6.

## Quest Ranking
In addition to scoring each quest report, each team
quest will be ranked in quintiles (1-5) to provide feedback on the
relative quality of the technical solution and report. This is a
useful diagnostic to understand relative effort and quality of
submitted work vs. your peers.

## Grade Computation:
The intent of the course is to realize the course outcomes for each
student through completion of individual assignments and
quests. Students who fail to complete a minimum set of assignments
and/or quests will not pass the course.  Conversely, the quests are
designed to be challenging. Completing all of the assignments
successfully is intended to earn a high grade.

Variations in grades within teams will be due to differences in
individual skill performance, participation in class, and evidence of
effort as observed in GitHub, Piazza, and in class.

The Fall 2023 grade breakdown was
approximatly as follows: (Note that the number of skills varies each year.)

- A: > 915 total points
- B: > 800 total points
- C: > 721 total points

## Use of ChatGPT and the like:

ChatGPT and similar AI chatbots are emerging as new tools to expedite
the development of software solutions. Our experience to date with
ChatGPT and the ESP32 programming shows that the AI will
enthusiastically produce solutions; however, the validity and context
of these solutions is often garbled. With several years of AI use in the
course, the following observations emerge:

- It is a bad idea to use AI to replace learning fundamental concepts --
these are the ones that are handy to sythesize higer-order
solutions and design.

- If you let AI do everything, then you are abdicating comprehension
to the AI. You are left with no understanding of the problem you are
solving.

- It is difficult to debug code that you have not written
yourself. This is true without AI, but just amplifies the challenge.

- I don't like reading AI-generated reports. They are typically
well-organized, but lack real insight to what you have experienced in
the design and development efforts.

- When reusing code, students tend to repeat existing code rather than
  build modular code. This leads to other problems including resource
  conflicts and performance degradation.

So I have some requests if you are going to use AI in your skills and
quests:

1. [Skills] Start with example code and try to understand how it works
rather than going straight to AI

2. [Quests] Use a design process model and then synthesize your
problem and then your solution. This is best on pencil and paper or
whiteboard with participation by your team. Divide and conquer

3. [Quests] Use design patterns -- these are intended to be
translatable into different contexts and language models

4. [Quests] Identify test cases for your individual pieces and your
overall solution. Don't forget the edge cases.

5. [Quests] Beware of clumping repetive code into solutions. This will
be assessed as poor quality of your solution when detected.

And some requirements:

1. You must indicate in your reports when and how  you have used an AI to
produce a solution or fragment. This should be reported in the code and readmes

2. You are responsible for understanding the results that you adopt;
the expectation is that you can defend the solution and justify its
correctness

## Other Misc. Requirements
- Each submitted solution requires a photo of the demo (still or video) that includes your student ID
- All student repos should be in the scope of the EC444 organization and must be private
- When posting skill solutions, you should post any adopted code (but not build files)


## Learning Objectives

The course is meant to be a hands-on, giving students the opportunity
to learn topics in cyberphysical and IoT systems, and then put those
concepts to practice by developing and debugging small scale connected
microcontroller systems. The course goals are to introduce students to

1. Embedded microcontrollers and I/O
2. Cyberphysical systems concepts and real-time software
3. Modern wireless and connected technology, and
4. Hardware and software development, debugging, and collaboration and management tools
